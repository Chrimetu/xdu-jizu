> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/weixin_45863060/article/details/125010512)

#### 文章目录

*   [计算机中的二进制除法](#_1)
*   *   [一. 原码除法的规则](#_2)
    *   [二. 恢复余数法](#_8)
    *   [三. 加减交替法](#_22)

计算机中的[二进制除法](https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%99%A4%E6%B3%95&spm=1001.2101.3001.7020)
-------------------------------------------------------------------------------------------------------------------

### 一. [原码](https://so.csdn.net/so/search?q=%E5%8E%9F%E7%A0%81&spm=1001.2101.3001.7020)除法的规则

**原码除法运算规则如下：**

*   （1）除数≠0。对于定点纯小数，| 被除数 |<| 除数 |, 否则商的整数位会被舍弃；对于定点纯整数，| 被除数 |>| 除数 |, 否则商直接为 0。
*   （2）与原码乘法类似，原码除法的商中，符号和数值也是分别处理的。商的符号等于被除数的符号与除数符号的异或，而商的数值等于被除数的数值除以除数的数值。
*   （3）将商的符号与数值拼接在一起即可得到商的原码。

### 二. 恢复余数法

> 在实际构成除法器时，保持除数的位置不动，使余数每次左移一位，来达到类似手算右移除数的效果，使运算单元的有效位数保持不变。

**恢复余数法算法描述（定点纯小数）：**

*   (1) 被除数首先左移一位，减除数，若够减，上商为 1，若不够减，上商为 0，同时加除数——恢复余数
*   (2) 余数左移一位，减除数，若够减，上商为 1，若不够减，上商为 0，同时加除数——恢复余数。重复此过程，直到除尽或精度达到要求为止。  
    ![](https://img-blog.csdnimg.cn/c800668634064017add703383b19fc1a.png)

值得注意的是： 在除的过程中，减 | Y | 是利用补码加法来实现的，所以为了防止补码相加溢出，可见在运算过程中同样设置了双符号位来防止溢出。即当低位符号位被溢出的进位侵占时，高位的符号位仍能保持原来的符号位数值。

恢复余数法的缺点： 在运算位数相同的情况下，不同的被除数和除数在运算中何时需要恢复余数不同，运算时间不一致，实现起来不便控制。

### 三. 加减交替法

为了推导出加减交替的法的原理，首先回顾分析恢复余数法：  
![](https://img-blog.csdnimg.cn/e320dca1325643f18e49e870dbd98c8b.png)  
也就是说，若第 i 次余数减除数得到的余数 R i < 0 R_i<0 Ri​<0，则不需要立即加除数来恢复余数，而是将其左移一位，变为 2 R i 2R_i 2Ri​，到第 i+1 次余数运算时加除数，即 R i + 1 = 2 R i + B R_{i+1}=2R_i+B Ri+1​=2Ri​+B

因此加减交替法的规则可描述如下：

*   (1) 若余数 R>=0，则商 1，余数左移一位，减除数
*   (2) 若余数 R<0，则商 0，余数左移一位，加除数

![](https://img-blog.csdnimg.cn/6a4dd8fa30ef4717b18c5f0189473624.png)

值得注意的是：假如计算到最后一步时发现余数 R<0，则没有办法左移并进行下一步的加减交替来让 i+1 次操作加余数。所以此时我们应该采用恢复余数法，让最后的余数加回除数。