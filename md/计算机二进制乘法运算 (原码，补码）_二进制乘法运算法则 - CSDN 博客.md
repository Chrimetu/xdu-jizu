> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/weixin_45863060/article/details/124949059)

计算机[二进制乘法](https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B9%98%E6%B3%95&spm=1001.2101.3001.7020)运算 (原码，补码）
---------------------------------------------------------------------------------------------------------------------------

#### 文章目录

*   [计算机二进制乘法运算 (原码，补码）](#_0)
*   [一. 原码的一位乘法](#_3)
*   *   [1. 乘法规则](#1_4)
    *   [2. 算法描述](#2_9)
    *   [3. 运算过程](#3_15)
    *   [4. 运算电路](#4_20)
*   [二. 补码的乘法运算——布斯（Booth）法](#Booth_25)
*   *   [1. 原理推导](#1_26)
    *   [2. 运算法则](#2_30)
    *   [3. 运算过程](#3_42)
    *   [4. 运算电路](#4_48)

一. [原码](https://so.csdn.net/so/search?q=%E5%8E%9F%E7%A0%81&spm=1001.2101.3001.7020)的一位乘法
----------------------------------------------------------------------------------------

### 1. 乘法规则

*   （1）乘积的符号位为：被乘数的符号位与乘数的符号位相异或
*   （2）乘积的数值为被乘数的数值与乘数的数值之积，即：  
    ∣ Z ∣ = ∣ X ∗ Y ∣ = ∣ X ∣ ∗ ∣ Y ∣ |Z|=|X*Y|=|X|*|Y| ∣Z∣=∣X∗Y∣=∣X∣∗∣Y∣
*   （3）乘积的原码为： [Z] 原 = [ X ∗ Y ] 原 = ( x 0 ⨁ y 0 ) ( ∣ X ∣ ∗ ∣ Y ∣ ) {[Z]_原}=[X*Y]_原 =(x_0\bigoplus y_0)(|X|*|Y|) [Z] 原​=[X∗Y] 原​=(x0​⨁y0​)(∣X∣∗∣Y∣)

### 2. 算法描述

设置一个寄存器 D，开始置 0，运算中存放部分积的高位，最后存放数值乘积的高位。  
用一个寄存器 A，开始时存放乘数，运算中存放 D 右移后不参与运算的部分积的低位和乘数的未运算位，最后存放数值乘积的低位。寄存器 B 存放被乘数。

从乘数的最低为开始运算，若为 1，则被乘数加到部分积 D；若为 0，则部分积加 0. 部分积和乘数联合右移 1 位。再次检测乘数的次低位，若为 1，则被乘数加到部分积；若为 0，则部分积加 0。部分积和乘数联合右移 1 位。上述过程循环进行，直到乘数各位运算完毕。

### 3. 运算过程

注意运算中在最高数值位前多设置了 1 位的目的是防止原码相加产生溢出。  
如果产生溢出，溢出的位会被多设置的高 1 位先保存，然后通过下一次右移移动到数值位进行运算。以保证运算结果的正确性。  
![](https://img-blog.csdnimg.cn/62bacd964b82470382933443eeeb8452.png)

### 4. 运算电路

原码一位乘法的运算电路框图如下：  
![](https://img-blog.csdnimg.cn/cc0462ccb21545629362fe42311f0da4.png)

二. 补码的乘法运算——布斯（Booth）法
----------------------

### 1. 原理推导

![](https://img-blog.csdnimg.cn/bdf5383caef042efb22b893c716bd95b.png)

### 2. 运算法则

*   如果后项减前项为 0，则部分积 + 0
*   如果后项减前项为 1，则部分积 + [x] 补 [x]_补 [x] 补​
*   如果后项减前项为 - 1，则部分积 + [ − x ] 补 [-x]_补 [−x] 补​  
    ![](https://img-blog.csdnimg.cn/5f13c1cab46b41ac9af78d05c73ee650.png)

**布斯算法可描述如下：**

*   （1）乘数与被乘数均用补码表示，连同符号位一起参与运算
*   （2）乘数最低位后增加一个附加位（用 A − 1 A_{-1} A−1​表示）, 设定初始值为 0.
*   （3）从附加为开始，根据上面所述的操作完成运算

### 3. 运算过程

注意在运算过程中设置了两个符号位，高 1 位的符号位设置的目的是防止补码运算产生的溢出。  
假如数值位的运算产生进位，同时导致向符号位进位时，低 1 位的符号位改变为新数值为的最高位，而更高位的符号位依然可以保持原来符号位的值，再通过联合右移就可以防止溢出保证运算正常进行。  
![](https://img-blog.csdnimg.cn/e64de0f5bc5d4c50ad6b83713cae91ad.png)  
注意：对于小数运算，在最后一次循环中不做 DA 右移而将 A 的最低位置 0，从而在 DA 中得到小数相乘运算的正确结果。

### 4. 运算电路

![](https://img-blog.csdnimg.cn/15d2f944a91440b3b36cf4e4c41f9bee.png)